Traceback (most recent call last):
  File "/home/alex/usr/venv/emd-paper/lib64/python3.10/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/alex/usr/venv/emd-paper/lib64/python3.10/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/home/alex/usr/venv/emd-paper/lib64/python3.10/site-packages/jupyter_core/utils/__init__.py", line 166, in wrapped
    return loop.run_until_complete(inner)
  File "/usr/lib64/python3.10/asyncio/base_events.py", line 649, in run_until_complete
    return future.result()
  File "/home/alex/usr/venv/emd-paper/lib64/python3.10/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/home/alex/usr/venv/emd-paper/lib64/python3.10/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/alex/usr/venv/emd-paper/lib64/python3.10/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
experiment_iter = tqdm(exp_conds, "Exp. cond.")
for T, œÉ, œÑ, œÅ, N in experiment_iter:
    if (T, œÉ, œÑ, œÅ, N) in (frames_realizations.keys() & frames_autocorr.keys())  :
        continue
    
    noise = ColoredNoise(0, T, corr_time=œÑ, scale=œÉ, impulse_density=œÅ, rng=seedseq)
    t_arr = np.linspace(noise.t_min, noise.t_max, int(10*T/noise.œÑ))

    ## Generate the realizations and compute their autocorrelation ##
    L = len(t_arr)
    Œît = np.diff(t_arr).mean()
    norm = signal.correlate(np.ones(L), np.ones(L), mode="same")  # Counts the number of sums which will contribute to each lag
    lags = signal.correlation_lags(L, L, mode="same") * Œît
    Œæ_arr = np.empty((N, L))
    CŒæ_arr = np.empty((N, L))
    for i, key in enumerate(tqdm(seedseq.spawn(N), "Seeds", leave=False)):
        _noise = noise.new(rng=key)
        Œæ = np.fromiter((_noise(t) for t in t_arr), count=len(t_arr), dtype=float)
        Œæ_arr[i] = Œæ
        CŒæ   = signal.correlate(Œæ, Œæ, mode="same") / norm
        CŒæ_arr[i] = CŒæ
    CŒæ = CŒæ_arr.mean(axis=0)

    ## Generator realization curves ##
    realization_samples = hv.Overlay([
        hv.Curve(zip(t_arr, _Œæ), kdims=dims.t, vdims=dims.Œæ, label="Single realization")
        for _Œæ in Œæ_arr[:n_realizations_shown]
    ])
    
    ## Generate autocorr curves ##
    autocorr_samples = hv.Overlay([
        hv.Curve(zip(lags, _CŒæ), kdims=dims.Œît, vdims=dims.Œæ2, label="Single realization")
        for _CŒæ in CŒæ_arr[:n_realizations_shown]]
    )
    avg =  hv.Curve(zip(lags, CŒæ), kdims=dims.Œît, vdims=dims.Œæ2, label=f"Average ({N} realizations)")
    target = hv.Curve(zip(lags, noise.autocorr(lags)), kdims=dims.Œît, vdims=dims.Œæ2, label="Theoretical")
    
    ## Compute axis range so it is appropriate for mean and target autocorr ‚Äì individual realizations may be well outside this range ##
    ymax = max(avg.range("Œæ2")[1], target.range("Œæ2")[0])
    ymin = min(avg.range("Œæ2")[0], target.range("Œæ2")[0])
    Œîy = ymax-ymin
    ymax += 0.05*Œîy
    ymin -= 0.05*Œîy
    # Round ymin down, round ymax up
    p = math.floor(np.log10(ymax-ymin)) + 2  # +2: between 10 and 100 ticks in the range
    new_range = (round(math.floor(ymin * 10**p) / 10**p, p),
                 round(math.ceil (ymax * 10**p) / 10**p, p))

    ## Assemble figures ##
    # Use random shades of grey for realization curves so we can distinguish them
    shades = np.random.uniform(.45, .8, size=n_realizations_shown)
    
    fig_autocorr = autocorr_samples * avg * target
    fig_autocorr.opts(ylim=new_range)
    fig_autocorr.opts(
        hv.opts.Curve(height=300, width=400),
        hv.opts.Curve("Curve.Single_realization", color="#DDD"),
        hv.opts.Curve("Curve.Average", color=colors[0]),
        hv.opts.Curve("Curve.Prescribed", color=colors[1], line_dash="dashed"),
        hv.opts.Overlay(title="Autocorrelation", legend_position="top"),
    )
    for curve, c in zip(fig_autocorr.Curve.Single_realization, shades):
        curve.opts(color=(c,)*3)
    
    fig_realizations = realization_samples
    fig_realizations.opts(
        hv.opts.Curve(height=300, width=400),
        #hv.opts.Curve("Curve.Single_realization", color="#DDD"),
        hv.opts.Overlay(title="Noise realizations", show_legend=False)
    )
    for curve, c in zip(fig_realizations, shades):
        curve.opts(color=(c,)*3)
    
    frames_realizations[(T, œÉ, œÑ, œÅ, N)] = fig_realizations
    frames_autocorr[(T, œÉ, œÑ, œÅ, N)] = fig_autocorr
------------------

----- stderr -----
No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mAttributeError[0m                            Traceback (most recent call last)
Cell [0;32mIn[11], line 17[0m
[1;32m     15[0m CŒæ_arr [38;5;241m=[39m np[38;5;241m.[39mempty((N, L))
[1;32m     16[0m [38;5;28;01mfor[39;00m i, key [38;5;129;01min[39;00m [38;5;28menumerate[39m(tqdm(seedseq[38;5;241m.[39mspawn(N), [38;5;124m"[39m[38;5;124mSeeds[39m[38;5;124m"[39m, leave[38;5;241m=[39m[38;5;28;01mFalse[39;00m)):
[0;32m---> 17[0m     _noise [38;5;241m=[39m [43mnoise[49m[38;5;241;43m.[39;49m[43mnew[49m[43m([49m[43mrng[49m[38;5;241;43m=[39;49m[43mkey[49m[43m)[49m
[1;32m     18[0m     Œæ [38;5;241m=[39m np[38;5;241m.[39mfromiter((_noise(t) [38;5;28;01mfor[39;00m t [38;5;129;01min[39;00m t_arr), count[38;5;241m=[39m[38;5;28mlen[39m(t_arr), dtype[38;5;241m=[39m[38;5;28mfloat[39m)
[1;32m     19[0m     Œæ_arr[i] [38;5;241m=[39m Œæ

Cell [0;32mIn[4], line 164[0m, in [0;36mColoredNoise.new[0;34m(self, **kwargs)[0m
[1;32m    155[0m [38;5;28;01mdef[39;00m [38;5;21mnew[39m([38;5;28mself[39m, [38;5;241m*[39m[38;5;241m*[39mkwargs):
[1;32m    156[0m [38;5;250m    [39m[38;5;124;03m"""[39;00m
[1;32m    157[0m [38;5;124;03m    Create a new model, using the values of this one as defaults.[39;00m
[1;32m    158[0m [38;5;124;03m    NB: By default, this uses the same RNG as the original, but will produce new[39;00m
[1;32m    159[0m [38;5;124;03m    times and weights (since it draws new points).[39;00m
[1;32m    160[0m [38;5;124;03m    If you want to avoid advancing the state of the orignal RNG, provide a new one.[39;00m
[1;32m    161[0m [38;5;124;03m    """[39;00m
[1;32m    162[0m     defaults [38;5;241m=[39m [38;5;28mdict[39m(t_min[38;5;241m=[39m[38;5;28mself[39m[38;5;241m.[39mt_min, t_max[38;5;241m=[39m[38;5;28mself[39m[38;5;241m.[39mt_max, corr_time[38;5;241m=[39m[38;5;28mself[39m[38;5;241m.[39mœÑ,
[1;32m    163[0m                     scale[38;5;241m=[39m[38;5;28mself[39m[38;5;241m.[39mœÉ,
[0;32m--> 164[0m                     impulse_density[38;5;241m=[39m[38;5;28mself[39m[38;5;241m.[39mœÅ, rng[38;5;241m=[39m[38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mrng[49m)
[1;32m    165[0m     [38;5;28;01mreturn[39;00m ColoredNoise([38;5;241m*[39m[38;5;241m*[39m(defaults [38;5;241m|[39m kwargs))

[0;31mAttributeError[0m: 'ColoredNoise' object has no attribute 'rng'

